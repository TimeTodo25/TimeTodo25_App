import 'dart:async';import 'package:flutter_bloc/flutter_bloc.dart';import 'package:time_todo/bloc/linear_timer/linear_timer_event.dart';import 'package:time_todo/bloc/linear_timer/linear_timer_state.dart';import 'package:time_todo/entity/timer/timer_tbl.dart';import 'package:time_todo/repository/timer_repository.dart';import 'package:time_todo/ui/todo/widget/timer_log/linear_timer_log.dart';import '../../ui/todo/widget/timer/ticker.dart';import '../../ui/todo/widget/timer_log/timer_log_segment.dart';class LinearTimerBloc extends Bloc<LinearTimerEvent, LinearTimerState> {  final Ticker _ticker;  StreamSubscription<int>? _tickerStream;  final LinearTimerLog _linearTimerLog = LinearTimerLog(); // 타이머 시작, 정지 기록  TimerModel? currentTimerModel;  TimerModel? lastTimerModel;  LinearTimerBloc({required Ticker ticker})      : _ticker = ticker,        super(LinearTimerInitial(            runningDuration: 0, stoppingDuration: 0, timerModels: [])) {    on<TimerStart>(_onStarted);    on<TimerPause>(_onPaused);    on<TimerResumed>(_onResumed);    on<LinearTimerReset>(_onReset);    on<TimerStop>(_onStop);    on<TimerRunTicked>(_onRunTicked);    on<TimerStopTicker>(_onStopTicker);    on<AddTimerHistory>(_onAddTimerHistory);    on<FetchTimerHistory>(_onFetchTimerHistory);    on<UpdateTimerHistory>(_onUpdateTimerHistory);  }  // 타이머 취소  void cancel() {    _tickerStream?.cancel();    _tickerStream = null;  }  void _startTicker(void Function(int) onTick) {    cancel();    _tickerStream = _ticker.tick().listen(onTick);  }  TimerModel _createTimerModel(String? totalTm) {    int defaultIdx = 1;    int newIdx = _linearTimerLog.logs.isEmpty ? defaultIdx : _linearTimerLog.logs.last.idx! + 1;    return TimerModel(      idx: newIdx,      historyType: TimerLogType.started,      historyStartDt: DateTime.now().toIso8601String(),      historyEndDt: '', // 아직 멈추지 않았으므로 빈 값      totalTm: totalTm ?? '',      todoIdx: 0,    );  }  void _onStarted(TimerStart event, Emitter<LinearTimerState> emit) {    _startTicker((duration) => add(TimerRunTicked(duration: duration))); // run 타이머 실행    currentTimerModel = _createTimerModel(event.runningDuration.toString()); // 새 타이머 모델 생성    emit(LinearTimerRun(        runningDuration: event.runningDuration ?? 0,        stoppingDuration: 0,        timerModels: []));  }  void _onPaused(TimerPause event, Emitter<LinearTimerState> emit) {    _startTicker((duration) => add(TimerStopTicker(duration: duration))); // 정지 시간을 세는 타이머 실행    if (currentTimerModel != null) {      lastTimerModel = currentTimerModel;      // 현재 시간으로 EndDt 업데이트      currentTimerModel = currentTimerModel!.copyWith(        historyStartDt: lastTimerModel!.historyStartDt,        historyEndDt: DateTime.now().toIso8601String(),        totalTm: event.runningDuration.toString(),      );      _linearTimerLog.updateAllLogs(currentTimerModel!);    }    emit(LinearTimerPause(        runningDuration: state.runningDuration,        stoppingDuration: 0,        timerModels: List<TimerModel>.from(_linearTimerLog.logs)    ));  }  void _onResumed(TimerResumed event, Emitter<LinearTimerState> emit) {    _startTicker((duration) => add(TimerRunTicked(duration: duration))); // run 타이머 실행    lastTimerModel = currentTimerModel;    // 멈춘 시간 기록    currentTimerModel = currentTimerModel!.copyWith(      historyType: TimerLogType.paused, // 일시정지한 시간 기록      historyStartDt: lastTimerModel!.historyEndDt,      historyEndDt: DateTime.now().toIso8601String(),      totalTm: event.stoppingDuration.toString(),    );    _linearTimerLog.updateAllLogs(currentTimerModel!);    currentTimerModel = _createTimerModel(null); // 새 타이머 모델 생성    emit(LinearTimerRun(      runningDuration: event.stoppingDuration,      stoppingDuration: 0,      timerModels: List<TimerModel>.from(_linearTimerLog.logs),    ));  }  // 타이머 초기화  void _onReset(LinearTimerReset event, Emitter<LinearTimerState> emit) {    cancel();    _linearTimerLog.clearLogs();    currentTimerModel = null;    lastTimerModel = null;    emit(const LinearTimerInitial(        runningDuration: 0, stoppingDuration: 0, timerModels: []));  }  void _onStop(TimerStop event, Emitter<LinearTimerState> emit) {    cancel();    emit(LinearTimerStop(runningDuration: 0));  }  // 진행중 타이머의 tick 처리  void _onRunTicked(TimerRunTicked event, Emitter<LinearTimerState> emit) {    emit(LinearTimerRun(      runningDuration: event.duration,      stoppingDuration: 0,      timerModels: state.timerModels,    ));  }  // 멈춤 타이머의 tick 처리  void _onStopTicker(TimerStopTicker event, Emitter<LinearTimerState> emit) {    emit(LinearTimerPause(      runningDuration: 0,      stoppingDuration: event.duration,      timerModels: state.timerModels,    ));  }  void _onAddTimerHistory(AddTimerHistory event,      Emitter<LinearTimerState> emit) async {    try {      final List<TimerModel> timerHistories = [];      for (final log in state.timerModels) {        timerHistories.add(          TimerModel(            idx: null,            historyStartDt: log.historyStartDt,            historyEndDt: log.historyEndDt,            historyType: log.historyType,            totalTm: log.totalTm,            todoIdx: event.todoIdx,            syncIdx: null,            syncCategoryIdx: null,            syncDt: null,          ),        );      }      if (timerHistories.isNotEmpty) {        await TimerRepository.insertTimerHistory(timerHistories);      }    } catch (e) {      print("onAddTimerHistory 중 에러 발생: $e");    }  }  Future<void> _onFetchTimerHistory(      FetchTimerHistory event, Emitter<LinearTimerState> emit) async {    try {      final timerHistories = await TimerRepository.getTimerHistoriesByTodoIndex(event.todoIdx) ?? [];      if (timerHistories.isEmpty) return;      emit(LinearTimerRun(        runningDuration: state.runningDuration,        stoppingDuration: state.stoppingDuration,        timerModels: timerHistories,        status: LinearTimerStatus.success      ));    } catch (e) {      print("_onFetchTimerHistory 중 에러 발생: $e");    }  }  Future<void> _onUpdateTimerHistory(      UpdateTimerHistory event, Emitter<LinearTimerState> emit) async {    try {      final newTimerHistory = state.timerModels;      await TimerRepository.updateTimerHistoryIfChanged(newTimerHistory);    } catch (e) {      print("_onUpdateTimerHistory 수정 저장 중 에러 발생 $e");    }  }}